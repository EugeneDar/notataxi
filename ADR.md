## ADR

Архревьюер: TODO кто?

### Какую задачу мы решаем?

Разрабатываем сервис хранения и обработки информации о заказах.


### Доменная область

TODO Что это? Мб не писать?


### Пользовательские сценарии

TODO переформулировать вообще все предложения в adr в наклонении "наш сервис должен...", а не "наш сервис уже...".

У нашего сервиса должно быть два вида пользователей: заказчики и исполнители. Заказчики создают и отменяют заказы, а исполнители получают информацию о назначенных им заказах.

Запросы от заказчиков должны приходить в наш сервис проходя через сторонний сервис, который назначает заказы исполнителям. Поэтому наш сервис не должен заниматься назначением заказов исполнителям.


### Функциональные требования

##### Роли пользователей

- Заказчик
- Исполнитель заказов

##### Сценарии использования

- Заказчики будут создавать заказы, внешний с нашей точки зрения сервис будет назначать их исполнителям и присылать нам запрос о заказе от такого-то пользователя с таким-то исполнителем. Если приходит запрос на назначение заказа исполнителю, который уже исполняет какой-то заказ, то ему должен назначаться новый, а старый должен получать статус завершенного. Таким образом на каждый заказ должен назначаться ровно один исполнитель, и на каждого исполнителя одновременно должно быть назначено не больше одного заказа.
- Исполнители постоянно находятся на линии и опрашивают нас раз в минуту, чтобы узнать, какой заказ им в данный момент назначен.
- Также заказчики могут отменять заказы. В этом случае заказ получает статус отмененного, больше с этим заказом ничего не происходит, его исполнитель становится свободным.

##### Требования по платформам (desktop, mobile и т.д.)

Нам это не актуально, мы никак не различаем трафик desktop/mobile.


### Нефункциональные требования

##### Взаимодействие с источниками

Сервис должен получать данные из следующих источников:

1. начальная конфигурация сервера (`config`)
2. данные о заказе (`order`)
3. повышающий коэффициент зоны заказа (`zone`)
4. данные о платных дорогах в зоне заказа (`toll-roads`)
5. данные об исполнителе (`executor`)
6. фоллбэк-источник данных об исполнителе (`executor-fallback`)

Цена заказа должна формироваться из источников 2-4.

##### Latency

Latency не должно расти при длительной нагрузке с rps не более, чем заданным.

##### Масштабируемость


Требуемые значения rps по каждому из видов запросов (могут быть одновременно):
- 100 rps на создание заказов
- 8333 rps на узнавание исполнителями статусов
- 50 rps на отмену заказов

Система должна линейно масштабироваться к нагрузке.

##### Отказоустойчивость

Источник `order` является *критичным*. Это значит, что его ответы нужны всегда в самом свежем виде, нельзя применять кэширование или использовать фоллбеки (дефолтное значение).

Остальные четыре источника *некритичные*. Это значит, что при их отказе их ответы можно заменять. А именно:

1. `config`: кэш, обновляемый каждую минуту.
2. `zone`: LRU-кэш. Данные старше 10 минут не должны использоваться, то есть в этом случае нужно считать, что данных нет.
3. `toll-roads`: кэш + фоллбэк, если в кэше ничего нет.
4. `executor`: поход на fallback-источник данных (`executor-fallback`).

##### Требования по срокам хранения данных

Бесконечно. Считаем, что 20 лет.


### Решение

##### API

TODO внешнее API (3 ручки) максимально подробно (все коды ответов в разных случаях). Это Женя или Серёжа напишите пж.

##### Архитектура

TODO Сколько у нас микросервисов, какие микросервисы, какие БД, обязательно схема таблиц в БД. Точно нужно нарисовать схему. Подробнее, что нужно изобразить, есть на вики в конце страницы в разделе "Схема системы".

Основная БД -- БД заказов. Её схема: TODO.

Сервис должен состоять из двух микросервисов:
- Микросервис заказов. Занимается всем взаимодействием с БД заказов и с вторым микросервисом. Не делает рассчет стоимости заказа и походы в источники.
- Микросервис источников делает всю логику походов в источники. То есть сами походы и принятие решений о замене ответа кэшом или фоллбэком. В БД заказов он не ходит. Для кэширования ответов тех источников, для которых это нужно, применяется TODO.

##### Взаимодействие микросервисов

Для взаимодействия двух микросервисов между собой нужно использовать gRPC. Это поможет снизить размер сообщений, накладные расходы на их парсинг и упростит реализацию (поскольку из протобуфов генерируется код).

##### Рассчет требуемой нагрузки

TODO Сколько rps на второй микросервис. Подробно рассчитать требуемый объем хранилища в БД, с учетом репликации(?). Сразу не знаем, придется ли шардировать микросервис заказов с целью увеличения его пропускной способности, но давайте напишем, как будет зависеть кол-во rps на один шард при k шардов. 
