# Отчет

## Роли

dixitix:
1) написала тесты сервисные + нагрузочные, разобралась, как работать с locust
2) в основном продумывала архитектуру
3) писала отчет

sermir2003: 
1) дописал за EugeneDar писать сервис заказов;
2)  и настроил подключение к ней; 
3) замерял производительность orders
4) рефакторил код orders много
5) ADR доделывал до идеального состояния

EugeneDar:
1) создал первоначально в клауде всё
2) написал первую минимальную версию с заглушками orders
3) поднял БД как managed service
4) писал отчет

Dmitry909:
1) написал первоначальные протобуфы (потом немного поменялось)
2) написал моки 
3) половина работы с кубером
4) ADR писал

Navalgan:
1) Написал sources полностью
2) Рефакторил код
3) Написал поход из orders в sources

readme писали все

## Тесты

### Заглушки источников данных

В системе реализовано 6 сервисов-заглушек на Python с использованием gRPC:

- Config Service (9090): Возвращает фиксированную минимальную цену 60

- Order Data Service (9091): Генерирует данные заказа с user_id, zone_id и базовой стоимостью на основе order_id

- Zone Data Service (9092): Выбирает случайную зону из фиксированного списка (Lyubertsy, Moscow, Severodvinsk и др.) с соответствующими коэффициентами

- Toll Roads Service (9093): Рассчитывает бонусную сумму на основе названия зоны

- Executor Profile Service (9094) и Executor Fallback Service (9095): Генерируют профиль исполнителя с тегами и рейтингом

#### Каждая заглушка имеет следующие общие характеристики

- Использует gRPC Server с ThreadPoolExecutor (10 рабочих потоков)

- Включает рефлексию gRPC для обнаружения сервисов

- Реализует соответствующий Servicer класс из сгенерированных protobuf файлов

#### Все заглушки используют набор общих вспомогательных функций для генерации тестовых данных:

- float_from_str(s) - генерирует детерминированное float число на основе хеша строки

- random_string_by_seed(seed, length) - генерирует случайную строку заданной длины с фиксированным seed

- random_sublist(list, subset_size, seed) - выбирает случайное подмножество элементов из списка

### Функциональные тесты

#### Sources Service Tests

Реализованы на Python + pytest + gRPC

Тестируемые компоненты:

- Config Service: проверка минимальной цены

- Executor Profile: валидация профиля исполнителя

- Order Data: проверка данных заказа

- Sources Service: комплексная проверка расчета цены

- Toll Roads: проверка бонусов

- Zone Data: валидация зон

Все тесты проверяют как успешные сценарии, так и обработку ошибок через gRPC статусы.

#### Orders Service Tests

Реализованы на Python + pytest + requests (REST API)

Тестируемые эндпоинты:

- Assign Order: назначение заказа

- Acquire Order: получение заказа

- Cancel Order: отмена заказа

Есть автоматическая очистка тестовых данных, генерация уникальных ID для каждого теста и подробное логирование ответов

### Нагрузочные тесты

Нагрузочное тестирование сервиса источников выполняется через Locust, эмулируя множество клиентов, делающих gRPC запросы к Sources сервису. Каждый клиент случайно выбирает order_id и executor_id из заготовленного списка и делает запрос GetOrderInfo. Тест собирает статистику по времени ответа, количеству ошибок и пропускной способности сервиса. Реализована обработка ошибок и подробное логирование для диагностики проблем производительности.

#### Принципы SOLID

##### Сервис заказов

###### (S) Single Responsibility Principle

- Контроллеры: Класс отвечает исключительно за обработку HTTP-запросов, маршрутизацию и взаимодействие с сервисами. Это обеспечивает четкое разделение обязанностей.
- Модуль: Фокусируется на взаимодействии с базой данных, что делает его ответственным только за управление данными.
- Модуль: Выполняет вспомогательные задачи, такие как работа с переменными окружения и генерация UUID.
- 
###### (O) Open/Closed Principle

- Код легко расширяется: для добавления новых обработчиков или методов можно добавить их в Service без модификации существующих.
- Модуль database позволяет управлять базой данных через функции, которые можно расширить, добавляя новые SQL-запросы.

###### (L) Liskov Substitution Principle

Использование интерфейсов GRPC (`SourcesServiceClient`) демонстрирует следование этому принципу. Замена реализации GRPC-клиента не потребует изменения основного кода контроллеров.
Это позволяет легко масштабировать или модифицировать работу с внешними сервисами.

###### (I) Interface Segregation Principle

Взаимодействие с базой данных, GRPC и другими компонентами строго определено методами, которые используются по назначению. Это исключает лишние зависимости.

###### (D) Dependency Inversion Principle

Верхний уровень (main) использует абстракции (например, `Service`), что позволяет гибко конфигурировать зависимости через инстанцирование объектов (`NewService()`).
Это упрощает настройку системы, повышая ее адаптивность.

##### Сервис ценообразования

###### (S) Single Responsibility Principle

Различные аспекты работы сервиса (например, работа с кешем, обращение к gRPC-клиентам) разнесены по разным модулям и методам. Например:

- Метод PriceCalculate отвечает только за вычисление цены.
- Метод GetOrderInfo сосредоточен на получении информации о заказе и объединении данных.

###### (O) Open/Closed Principle

Система легко расширяется благодаря использованию gRPC-клиентов. Если потребуется добавить новый сервис, достаточно определить новый gRPC-клиент, не модифицируя основной код.

###### (L) Liskov Substitution Principle

В данном сервисе не представлен так как в большей степени применим к наследованию.

###### (I) Interface Segregation Principle

Проект использует четко разделенные интерфейсы для работы с различными сервисами, такими как ConfigServiceClient, OrderDataServiceClient, и т.д. Это позволяет модульно взаимодействовать с каждым компонентом системы.

###### (D) Dependency Inversion Principle

gRPC-клиенты внедряются через интерфейсы, а не жестко привязываются к конкретным реализациям. Это облегчает тестирование и замену зависимостей.
